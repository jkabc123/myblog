{
  
    
        "post0": {
            "title": "Coroutine And Async",
            "content": "Coroutine 101 .",
            "url": "https://jkabc123.github.io/myblog/yield/generator/concurrent/2020/07/01/Coroutine-And-Async.html",
            "relUrl": "/yield/generator/concurrent/2020/07/01/Coroutine-And-Async.html",
            "date": " • Jul 1, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Magic of yield",
            "content": "Introduction . yield syntax was first introduced to Python in PEP 255. It was introduced to faciliate the concept of generator. In short, generator provides a kind of function which returns an immediate value to the caller, then it stops and its state is maintained so that it can be resumed later. . Then enhanced generator was proposed in PEP 342. It mainly introduced generator expression and send method. . Later on in PEP 380, syntax yield from was proposed to allow a generator to delegate parts of its operation to another generator. . These yield syntaxes and the programming techniques around them are so unqiue in Python, they become one of the trademarks magics Python produces and still facinate programmers till today. A better understanding of these techniques will not only make our code more clean and but also easy to understand and more efficient. . Note: All the code below run only in Python 3. . yield . To understand how yield works, let us have a look at a simple example which defines a function countdown which counts down from the number max and produces the value. . def countdown(max): n=0 while n&lt;max: print(&quot;Before yield&quot;, n) yield n n+=1 print(&quot;After yield&quot;,n) . countdown(3) . &lt;generator object countdown at 0x0000021F5B214148&gt; . gen=_ . next(gen) . Before yield 0 . 0 . next(gen) . After yield 1 Before yield 1 . 1 . next(gen) . After yield 2 Before yield 2 . 2 . next(gen) . After yield 3 . StopIteration Traceback (most recent call last) &lt;ipython-input-17-6e72e47198db&gt; in &lt;module&gt; -&gt; 1 next(gen) StopIteration: . From the example above you can tell, once you have a yield statement inside countdown function, it becomes a function returns generator object. . You can call next on gen. It will run to yield and then stops there. . When you call next on gen again, it continues to run from the previous state to the next yield. . You continue to call next on gen a few times until it exits the loop. Because now it can&#39;t reach the yield statement, it produces a StopIteration Exception. . If you return a value in the generator function, you can get the value by catching StopIteration. . def countdown(max): n=0 while n&lt;max: yield n n+=1 return n try: gen=countdown(3) while True: next(gen) except StopIteration as e: print(&quot;Stop:&quot;, e.value) . Stop: 3 . You can use generator to feed iteration. . for x in countdown(3): print(&quot;Count down:&quot;, x) . Count down: 0 Count down: 1 Count down: 2 . Apart from calling next on the generator, you can also send a value, close, and throw an exception to the generator. . In order to send value to a generator, you need to call next first. After that, each time you send a value, it gets the value and runs to the next yield. . def receiver(): while True: print(&quot;Before yield&quot;) item = yield print(&quot;Got:&quot;, item) print(&quot;After yield&quot;) #yield item . gen=receiver() . next(gen) . Before yield . gen.send(&quot;Hello&quot;) . Got: Hello After yield Before yield . To throw an exception on the generator, you just call gen.throw(). . gen=countdown(3) . next(gen) . 0 . gen.throw(Exception, &quot;Error&quot;) . Exception Traceback (most recent call last) &lt;ipython-input-8-e901ed0fa2f8&gt; in &lt;module&gt; -&gt; 1 gen.throw(Exception, &#34;Error&#34;) &lt;ipython-input-5-b618e9f54175&gt; in countdown(max) 2 n=0 3 while n&lt;max: -&gt; 4 yield n 5 n+=1 6 return n Exception: Error . To close the generator, you call gen.close() . def countdown(max): try: n=0 while n&lt;max: yield n n+=1 return n except GeneratorExit: print(&quot;Exit:&quot;, n) . gen=countdown(3) . next(gen) . 0 . gen.close() . Exit: 0 . yield from . Using yield from, you can delegate parts of the generator to another generator. . def chain(x,y): yield from x yield from y . x=[1,2,3] . y=[4,5,6] . list(chain(x,y)) . [1, 2, 3, 4, 5, 6] . list(chain(x,chain(x,y))) . [1, 2, 3, 1, 2, 3, 4, 5, 6] . Use case 1 . In Python, a common way to run computation in parallel is to use ThreadExecutorPool or ProcessExectorPool. . Below is an example how we can use this to calculate fibonacci number. . from concurrent.futures import ThreadPoolExecutor as Pool import time . def fib(n): if n&lt;=2: return 1 else: return fib(n-1)+fib(n-2) . pool = Pool(20) . fut=pool.submit(fib,40) . start=time.time() fut.result() end=time.time() print(&quot;total time:&quot;, (end-start)/60) . total time: 0.8523510853449504 . The code above all runs very good until it tries to get the result through fut.result(). Because in Python, future and thread are blocking operations. It will block other code to run and wait there until the result returns. . Sometimes we need it to be non-blocking so it gives other code to run while waiting for the result. For example, if you are doing some I/O operations at the same, they will get the chance to run. . Because yield has such ability to halt the code and resume it later on. We could use it to implment the non-blocking version of the code. . In 2014, Python Cookbook author David Beazley has presented the idea in his talk Generator, the frontier to use yield to turn thread and future to non-blocking. The following code is based on that talk. . First, we define a generator for the purpose of calculating the fibonacci number. . def cal_fib(n): res=yield pool.submit(fib,n) print(&quot;result:&quot;,res) return res . Next, we write a class called Task, which will wrap this generator and attach a call back function to the calculation. . class Task: def __init__(self,gen): self._gen=gen def run(self,value=None): try: fut=self._gen.send(value) fut.add_done_callback(self._wakeup) except StopIteration: print(&quot;Stop now&quot;) def _wakeup(self,fut): print(&quot;wake up:&quot;, fut.result()) result=fut.result() self.run(result) . fib_task=Task(cal_fib(40)) . start=time.time() fib_task.run() end=time.time() print(&quot;total time:&quot;, (end-start)/60) . total time: 0.00018332401911417642 wake up: 102334155 result: 102334155 Stop now .",
            "url": "https://jkabc123.github.io/myblog/yield/generator/concurrent/2020/06/27/Magic-of-yield.html",
            "relUrl": "/yield/generator/concurrent/2020/06/27/Magic-of-yield.html",
            "date": " • Jun 27, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "About . Peter Yang earned a Ph.D in Computer Cryptology a decade ago. Peter has been in IT industry for more than 15 years. His early career focused on designing threshold based cryptographical algorithms and teaching Computer Cryptology in university. Since 2015, he is mainly focused on Python and its ecosystem. . Contact . Peter can be contacted by sending email to pyoung1683@gmail.com . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jkabc123.github.io/myblog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}