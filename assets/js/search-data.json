{
  
    
        "post0": {
            "title": "Magic of yield",
            "content": "Introduction . yield syntax was first introduced to Python in PEP 255. It was introduced to faciliate the concept of generator. In short, generator provides a kind of function which returns an immediate value to the caller, then it stops and its state is maintained so that it can be resumed later. . Then enhanced generator was proposed in PEP 342. It mainly introduced generator expression and send method. . Later on in PEP 380, syntax yield from was proposed to allow a generator to delegate parts of its operation to another generator. . These yield syntaxes and the programming techniques around them are so unqiue in Python, they become one of the trademarks magics Python produces and still facinate programmers till today. A better understanding of these techniques will not only make our code more clean and but also easy to understand and more efficient. . Note: All the code below run only in Python 3. . yield . To understand how yield works, let us have a look at a simple example which defines a function countdown which counts down from the number max and produces the value. . def countdown(max): n=0 while n&lt;max: print(&quot;Before yield&quot;, n) yield n n+=1 print(&quot;After yield&quot;,n) . countdown(3) . &lt;generator object countdown at 0x0000021F5B214148&gt; . gen=_ . next(gen) . Before yield 0 . 0 . next(gen) . After yield 1 Before yield 1 . 1 . next(gen) . After yield 2 Before yield 2 . 2 . next(gen) . After yield 3 . StopIteration Traceback (most recent call last) &lt;ipython-input-17-6e72e47198db&gt; in &lt;module&gt; -&gt; 1 next(gen) StopIteration: . From the example above you can tell, once you have a yield statement inside countdown function, it becomes a function returns generator object. . You can call next on gen. It will run to yield and then stops there. . When you call next on gen again, it continues to run from the previous state to the next yield. . You continue to call next on gen a few times until it exits the loop. Because now it can&#39;t reach the yield statement, it produces a StopIteration Exception. . If you return a value in the generator function, you can get the value by catching StopIteration. . def countdown(max): n=0 while n&lt;max: yield n n+=1 return n try: gen=countdown(3) while True: next(gen) except StopIteration as e: print(&quot;Stop:&quot;, e.value) . Stop: 3 . You can use generator to feed iteration. . for x in countdown(3): print(&quot;Count down:&quot;, x) . Count down: 0 Count down: 1 Count down: 2 . Apart from calling next on the generator, you can also send a value, close, and throw an exception to the generator. . In order to send value to a generator, you need to call next first. After that, each time you send a value, it gets the value and runs to the next yield. . def receiver(): while True: print(&quot;Before yield&quot;) item = yield print(&quot;Got:&quot;, item) print(&quot;After yield&quot;) #yield item . gen=receiver() . next(gen) . Before yield . gen.send(&quot;Hello&quot;) . Got: Hello After yield Before yield . To throw an exception on the generator, you just call gen.throw(). . gen=countdown(3) . next(gen) . 0 . gen.throw(Exception, &quot;Error&quot;) . Exception Traceback (most recent call last) &lt;ipython-input-8-e901ed0fa2f8&gt; in &lt;module&gt; -&gt; 1 gen.throw(Exception, &#34;Error&#34;) &lt;ipython-input-5-b618e9f54175&gt; in countdown(max) 2 n=0 3 while n&lt;max: -&gt; 4 yield n 5 n+=1 6 return n Exception: Error . To close the generator, you call gen.close() . def countdown(max): try: n=0 while n&lt;max: yield n n+=1 return n except GeneratorExit: print(&quot;Exit:&quot;, n) . gen=countdown(3) . next(gen) . 0 . gen.close() . Exit: 0 .",
            "url": "https://jkabc123.github.io/myblog/yield/generator/concurrent/2020/06/27/Magic-of-yield.html",
            "relUrl": "/yield/generator/concurrent/2020/06/27/Magic-of-yield.html",
            "date": " • Jun 27, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "About . Peter Yang earned a Ph.D in Computer Cryptology a decade ago. Peter has been in IT industry for more than 15 years. His early career focused on designing threshold based cryptographical algorithms and teaching Computer Cryptology in university. Since 2015, he is mainly focused on Python and its ecosystem. . Contact . Peter can be contacted by sending email to pyoung1683@gmail.com . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jkabc123.github.io/myblog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}